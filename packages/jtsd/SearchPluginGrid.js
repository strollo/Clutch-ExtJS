
Ext.Loader.setConfig({
	enabled : true
});
Ext.require([
		'Ext.grid.*',
		'Ext.data.*',
		'Ext.util.*',
		'Ext.toolbar.Paging',
		'Ext.ModelManager',
		'Ext.tip.QuickTipManager'
	]);

Ext.override(Ext.grid.Panel, {
	initComponent : function () {
		this.autoGenerateColumn();
		this.checkGrouping();
		this.checkPaging();
		this.checkSearch();
		this.callParent(arguments);
	}
});

function StringCapitalize(str) {
	if (str == null) {
		return null;
	}
	return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * The columns are autogenerated from the model assigned to the store.
 * Usage:
 * <pre>
 * Ext.define('mymodel.Entry', {
 *			extend: 'Ext.data.Model',
 *			fields:[
 *				{name: 'id', type: 'int'}, // column will be not created
 *				{name: 'field1', type: 'string', visible: true},
 *				{name: 'field2', type: 'floatOrString', visible: false,
 *					// ... all the params of colum can be appended here  ...
 *					width: 80, text: 'The Label',
 *				}
 *			],
 *			idProperty: 'id'
 *		});
 * </pre>
 *
 * <p>Store sample:</p>
 * <pre>
 *      var gridStore = Ext.create(
 *			'Ext.data.Store',
 *			'mymodel.Entry',
 *			{
 *				url: <myurl>,
 *				proxy : {
 *					type : 'jsonp',
 *					root : 'data',
 *				},
 *				// paging of 50 entries
 *				pageSize: 50,
 *				// default sorting on dates desc
 *				sorters: [{property: 'date',direction: 'DESC'}]
 *			}
 *		);
 * </pre>
 *
 * <p>Instantiation:</p>
 * <pre>
 * var grid = Ext.create('JTSD.SearchPluginGrid', {
 *		model: <THE MODEL>,
 *		enableSearch: true,
 *		frame: false,
 *		store: <THE STORE>,
 *		title: _title ...
 * });
 * </pre>
 */
Ext.define('JTSD.SearchPluginGrid', {
	alias : 'widget.jtsdsearchgrid',
	extend : 'Ext.grid.Panel',
	autoDestroy : true,
	remoteFilter : true,

	viewConfig : {
		loadMask : true,
		forceFit : true,
		align : 'stretch',
	},

	/* Additional features - by default they are enabled */
	// Allows the auto generation of columns from the model
	enableAutoColumns : true,
	// Allows the automatic paging - the field (store.pageSize: 50) will deside the entries per page
	enablePaging : true,
	// Allows grouping on columns. To disable grouping on a column put (groupable: false) in the model.
	enableGrouping : true,
	// Enables the search plugin
	enableSearch : false,

	getToolBarItemByName : function (self, name) {
		t = self.dockedItems.items[2];
		for (var i = 0; i < t.items.items.length; i++) {
			if (t.items.items[i].name === name) {
				return t.items.items[i];
			}
		}
		return null;
	},

	onTextFieldReset : function (self) {
		this.store.clearFilter();
		this.store.load();
		searchBox = this.getToolBarItemByName(this, 'searchField');
		if (searchBox) {
			searchBox.setValue(null);
		}
	},

	onTextFieldChange : function (self) {
		this.store.clearFilter();

		this.store.filter({
			property : 'description',
			value : self.value,
			exactMatch : false,
			anyMatch : true,
			caseSensitive : false
		});
		this.store.load();
	},

	checkPaging : function () {
		var me = this;

		if (!Ext.isDefined(me.enablePaging) || me.enablePaging != true) {
			return;
		}
		// paging bar on the bottom
		me.bbar = Ext.create('Ext.PagingToolbar', {
				store : me.store,
				displayInfo : true,
				displayMsg : 'Displaying elems {0} - {1} of {2}',
				emptyMsg : "No elems to display",
			});
	},

	checkSearch : function () {
		var me = this;
		if ((!Ext.isDefined(me.enableSearch) || me.enableSearch != true)) {
			return;
		}

		var toolbar = me.getToolbar(me);
		toolbar.items.add(Ext.create('Ext.toolbar.Fill'));
		toolbar.items.add(Ext.create('Ext.toolbar.TextItem', {
				text : 'Search'
			}));
		toolbar.items.add(Ext.create('Ext.form.field.Text', {
				name : 'searchField',
				hideLabel : true,
				width : 200,

				listeners : {
					specialkey : function (field, e) {
						if (e.getKey() == e.ENTER) {
							me.onTextFieldChange(this);
						}
					}
				}
			}));
		toolbar.items.add(Ext.create('Ext.Button', {
				tooltip : 'Clear Filter',
				icon : 'icons/dialog_cancel.png',
				listeners : {
					click : function (self, e) {
						me.onTextFieldReset(this);
					}
				}
			}));

	},

	checkGrouping : function () {
		var me = this;
		if (!Ext.isDefined(me.enableGrouping) || me.enableGrouping != true) {
			return;
		}

		var groupingFeature = Ext.create('Ext.grid.feature.Grouping', {
				id : 'group',
				ftype : 'multigrouping',
				groupHeaderTpl : [
					'{name:this.formatName} ({rows:this.formatTotal})',
					//'{name:this.formatName} ({rows.length} Item{[values.rows.length > 1 ? "s" : ""]})',
					{
						formatName : function (name) {
							var sName = (name == "") ? "None " : name;
							return sName;
						},
						formatTotal : function (values) {
							var i = 0;
							var retval = 0;
							for (i = 0; i < values.length; i++) {
								retval += parseFloat(values[i].data.amount);
							}
							return retval.toFixed(2);
						}
					}
				],
			});

		if (me.enableGrouping === true) {
			if (me.features == null) {
				me.features = [groupingFeature];
			} else {
				me.features.push(groupingFeature);
			}
		}
	}, // checkGrouping

	autoGenerateColumn : function () {
		var me = this;

		if (Ext.isDefined(me.model) === false && Ext.isDefined(me.enableAutoColumns) === false) {
			console.log('SmartGrid: auto generate columns is not defined or model is missing.');
			return;
		}

		if (me.enableAutoColumns === true) {
			if (Ext.isString(me.model)) {
				me.model = Ext.ModelManager.getModel(me.model);
			}

			var modelFields = me.model.prototype.fields;
			me.columns = new Array();

			// Adding columns to grid
			for (var i = 0; i < modelFields.length; i++) {
				var modelField = modelFields.items[i];
				var fieldName = modelField.name;
				var fieldLabel = StringCapitalize(modelField.name);
				if (modelField.label != null) {
					fieldLabel = modelField.label;
				}
				var fieldType = modelField.type.type;

				if (modelField.GridOptions != null) {
					modelField = modelField.GridOptions;
				} else {
					modelField = new Object();
				}

				// Merges GridOptions section with Defaults one.
				// The GridOptions fields will not be overridden.
				if (modelFields.items[i].Defaults != null) {
					modelField = Ext.Object.merge(modelField, modelFields.items[i].Defaults);
				}

				// The special skip (bool) will not include in columns the current modelField.
				var mustSkip = (Ext.isDefined(modelField.skip) && (modelField.skip === true));

				// Skips hidden columns
				if (mustSkip) {
					continue;
				}

				var column = Ext.create('Ext.grid.column.Column', {
						header : fieldName,
						dataIndex : fieldName,
					});

				/*
				 * List of model fields not of type string that are to
				 * be included in the corresponding store.
				 */
				var sg_includeFields = ['renderer'];

				// Appends all the fields of the model to the column
				for (var property in modelField) {
					// These fields are not ported
					if (property[0] == '$')
						continue;
					if (typeof(modelField[property]) == 'string' ||
						typeof(modelField[property]) == 'boolean' ||
						typeof(modelField[property]) == 'number' ||
						// Particular fields (functions) that must be included
						sg_includeFields.indexOf(property) != -1) {
						column[property] = modelField[property];
					}
				}

				me.columns.push(column);
			}
		}

		if (me.columns.length == 0) {
			Ext.Error.raise('No fields declared in ' + me.model.$className + ' with property visible. Columns will not be created!');
		}
	} // autoGenerateColumn
});
